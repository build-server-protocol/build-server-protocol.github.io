"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[92],{197:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>a,metadata:()=>o,toc:()=>d});var s=t(3955),r=t(8379);const a={id:"rust",title:"Rust Extension",sidebar_label:"Rust"},i=void 0,o={id:"extensions/rust",title:"Rust Extension",description:"The following section contains Rust-specific extensions to the build server",source:"@site/generated/extensions/rust.md",sourceDirName:"extensions",slug:"/extensions/rust",permalink:"/docs/extensions/rust",draft:!1,unlisted:!1,editUrl:"https://github.com/build-server-protocol/build-server-protocol/edit/master/docs/extensions/rust.md",tags:[],version:"current",frontMatter:{id:"rust",title:"Rust Extension",sidebar_label:"Rust"},sidebar:"docs",previous:{title:"Python",permalink:"/docs/extensions/python"},next:{title:"sbt",permalink:"/docs/extensions/sbt"}},c={},d=[{value:"BSP version",id:"bsp-version",level:2},{value:"BSP Server remote interface",id:"bsp-server-remote-interface",level:2},{value:"RustWorkspace: request",id:"rustworkspace-request",level:3},{value:"RustWorkspaceParams",id:"rustworkspaceparams",level:4},{value:"RustWorkspaceResult",id:"rustworkspaceresult",level:4},{value:"RustPackage",id:"rustpackage",level:4},{value:"RustPackageOrigin",id:"rustpackageorigin",level:4},{value:"RustEdition",id:"rustedition",level:4},{value:"RustTarget",id:"rusttarget",level:4},{value:"RustTargetKind",id:"rusttargetkind",level:4},{value:"RustCrateType",id:"rustcratetype",level:4},{value:"Feature",id:"feature",level:4},{value:"FeaturesDependencyGraph",id:"featuresdependencygraph",level:4},{value:"RustCfgOptions",id:"rustcfgoptions",level:4},{value:"RustRawDependencies",id:"rustrawdependencies",level:4},{value:"RustDependencies",id:"rustdependencies",level:4}];function l(e){const n={code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"The following section contains Rust-specific extensions to the build server\nprotocol."}),"\n",(0,s.jsx)(n.h2,{id:"bsp-version",children:"BSP version"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"2.2.0"})}),"\n",(0,s.jsx)(n.h2,{id:"bsp-server-remote-interface",children:"BSP Server remote interface"}),"\n",(0,s.jsx)(n.h3,{id:"rustworkspace-request",children:"RustWorkspace: request"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Unstable"})," (may change in future versions)"]}),"\n",(0,s.jsx)(n.p,{children:"The Rust workspace request is sent from the client to the server to query for\nthe information about project's workspace for the given list of build targets."}),"\n",(0,s.jsxs)(n.p,{children:["The request is essential to connect and work with ",(0,s.jsx)(n.code,{children:"intellij-rust"})," plugin."]}),"\n",(0,s.jsxs)(n.p,{children:["The request may take a long time, as it may require building a project to some extent\n(for example with ",(0,s.jsx)(n.code,{children:"cargo check"})," command)."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["method: ",(0,s.jsx)(n.code,{children:"buildTarget/rustWorkspace"})]}),"\n",(0,s.jsxs)(n.li,{children:["params: ",(0,s.jsx)(n.code,{children:"RustWorkspaceParams"})]}),"\n",(0,s.jsxs)(n.li,{children:["result: ",(0,s.jsx)(n.code,{children:"RustWorkspaceResult"})]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"rustworkspaceparams",children:"RustWorkspaceParams"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Unstable"})," (may change in future versions)"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"export interface RustWorkspaceParams {\n  /** A sequence of build targets for workspace resolution. */\n  targets: BuildTargetIdentifier[];\n}\n"})}),"\n",(0,s.jsx)(n.h4,{id:"rustworkspaceresult",children:"RustWorkspaceResult"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Unstable"})," (may change in future versions)"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"export interface RustWorkspaceResult {\n  /** Packages of given targets. */\n  packages: RustPackage[];\n\n  /** Dependencies in `cargo metadata` as listed in the package `Cargo.toml`,\n   * without package resolution or any additional data. */\n  rawDependencies: RustRawDependencies;\n\n  /** Resolved dependencies of the build. Handles renamed dependencies.\n   * Correspond to dependencies from resolved dependency graph from `cargo metadata` that shows\n   * the actual dependencies that are being used in the build. */\n  dependencies: RustDependencies;\n\n  /** A sequence of build targets taken into consideration during build process. */\n  resolvedTargets: BuildTargetIdentifier[];\n}\n"})}),"\n",(0,s.jsx)(n.h4,{id:"rustpackage",children:"RustPackage"}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.code,{children:"crate"})," is the smallest amount of code that the Rust compiler considers at a time.\nIt can come in one of two forms: a binary crate or a library crate.\n",(0,s.jsx)(n.code,{children:"Binary crates"})," are programs you can compile to an executable that you can run,\nsuch as a command-line program or a server.\nEach must have a function called main that defines what happens when the executable runs.\n",(0,s.jsx)(n.code,{children:"Library crates"})," don't have a main function, and they don't compile to an executable.\nInstead, they define functionality intended to be shared with multiple projects."]}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.code,{children:"package"})," is a bundle of one or more crates that provides a set of functionality.\nIt contains a Cargo.toml file that describes how to build those crates.\nA package can contain many binary crates, but at most only one library crate.\nHowever, it must contain at least one crate, whether that's a library or binary crate."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'export interface RustPackage {\n  /** The package\'s unique identifier */\n  id: string;\n\n  /** The package\'s root path. */\n  rootUrl: URI;\n\n  /** The name of the package. */\n  name: string;\n\n  /** The version of the package. */\n  version: string;\n\n  /** Defines a reason a package is in a project. */\n  origin: RustPackageOrigin;\n\n  /** Code edition of the package. */\n  edition: RustEdition;\n\n  /** The source ID of the dependency, for example:\n   * "registry+https://github.com/rust-lang/crates.io-index".\n   * `null` for the root package and path dependencies. */\n  source?: string;\n\n  /** Corresponds to source files which can be compiled into a crate from this package.\n   * Contains only resolved targets without conflicts. */\n  resolvedTargets: RustTarget[];\n\n  /** Same as `resolvedTargets`, but contains all targets from this package.\n   * `targets` should be the subset of `allTargets`. */\n  allTargets: RustTarget[];\n\n  /** Set of features defined for the package (including optional dependencies).\n   * Each feature maps to an array of features or dependencies it enables.\n   * The entry named "default" defines which features are enabled by default. */\n  features: FeaturesDependencyGraph;\n\n  /** Array of features enabled on this package. */\n  enabledFeatures: Set<Feature>;\n\n  /** Conditional compilation flags that can be set based on certain conditions.\n   * They can be used to enable or disable certain sections of code during the build process.\n   * `cfgs` in Rust can take one of two forms: "cfg1" or "cfg2=\\"string\\"".\n   * The `cfg` is split by \'=\' delimiter and the first half becomes key and\n   * the second is aggregated to the value in `RustCfgOptions`.\n   * For "cfg1" the value is empty. */\n  cfgOptions?: RustCfgOptions;\n\n  /** Environment variables for the package. */\n  env?: EnvironmentVariables;\n\n  /** An absolute path which is used as a value of `OUT_DIR` environmental\n   * variable when compiling current package. */\n  outDirUrl?: URI;\n\n  /** File path to compiled output of a procedural macro crate.\n   * Procedural macros are macros that generate code at compile time.\n   * Contains files with file extensions: `.dll`, `.so` or `.dylib`. */\n  procMacroArtifact?: URI;\n}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"rustpackageorigin",children:"RustPackageOrigin"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'export type RustPackageOrigin = string;\n\nexport namespace RustPackageOrigin {\n  /** External dependency of [WORKSPACE] or other [DEPENDENCY] package. */\n  export const Dependency = "dependency";\n\n  /** The package comes from the standard library. */\n  export const Stdlib = "stdlib";\n\n  /** External dependency of [STDLIB] or other [STDLIB_DEPENDENCY] package. */\n  export const StdlibDependency = "stdlib-dependency";\n\n  /** The package is a part of our workspace. */\n  export const Workspace = "workspace";\n}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"rustedition",children:"RustEdition"}),"\n",(0,s.jsx)(n.p,{children:"The Rust edition."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'export type RustEdition = string;\n\nexport namespace RustEdition {\n  export const E2015 = "2015";\n\n  export const E2018 = "2018";\n\n  export const E2021 = "2021";\n}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"rusttarget",children:"RustTarget"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"RustTarget"})," contains data of the target as defined in Cargo metadata."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"export interface RustTarget {\n  /** The name of the target. */\n  name: string;\n\n  /** Path to the root module of the crate. */\n  crateRootUrl: URI;\n\n  /** A target's kind. */\n  kind: RustTargetKind;\n\n  /** Type of output that is produced by a crate during the build process.\n   * The crate type determines how the source code is compiled. */\n  crateTypes?: RustCrateType[];\n\n  /** The Rust edition of the target. */\n  edition: RustEdition;\n\n  /** Whether or not this target has doc tests enabled, and\n   * the target is compatible with doc testing. */\n  doctest: boolean;\n\n  /** A sequence of required features. */\n  requiredFeatures?: Set<Feature>;\n}\n"})}),"\n",(0,s.jsx)(n.h4,{id:"rusttargetkind",children:"RustTargetKind"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"export enum RustTargetKind {\n  /** For lib targets. */\n  Lib = 1,\n\n  /** For binaries. */\n  Bin = 2,\n\n  /** For integration tests. */\n  Test = 3,\n\n  /** For examples. */\n  Example = 4,\n\n  /** For benchmarks. */\n  Bench = 5,\n\n  /** For build scripts. */\n  CustomBuild = 6,\n\n  /** For unknown targets. */\n  Unknown = 7,\n}\n"})}),"\n",(0,s.jsx)(n.h4,{id:"rustcratetype",children:"RustCrateType"}),"\n",(0,s.jsxs)(n.p,{children:["Crate types (",(0,s.jsx)(n.code,{children:"lib"}),", ",(0,s.jsx)(n.code,{children:"rlib"}),", ",(0,s.jsx)(n.code,{children:"dylib"}),", ",(0,s.jsx)(n.code,{children:"cdylib"}),", ",(0,s.jsx)(n.code,{children:"staticlib"}),") are listed for\n",(0,s.jsx)(n.code,{children:"lib"})," and ",(0,s.jsx)(n.code,{children:"example"})," target kinds. For other target kinds ",(0,s.jsx)(n.code,{children:"bin"})," crate type is listed."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"export enum RustCrateType {\n  Bin = 1,\n\n  Lib = 2,\n\n  Rlib = 3,\n\n  Dylib = 4,\n\n  Cdylib = 5,\n\n  Staticlib = 6,\n\n  ProcMacro = 7,\n\n  Unknown = 8,\n}\n"})}),"\n",(0,s.jsx)(n.h4,{id:"feature",children:"Feature"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"export type Feature = string;\n"})}),"\n",(0,s.jsx)(n.h4,{id:"featuresdependencygraph",children:"FeaturesDependencyGraph"}),"\n",(0,s.jsx)(n.p,{children:"The feature dependency graph is a mapping between\nfeature and the features it turns on"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"export type FeaturesDependencyGraph = Map<Feature, Set<Feature>>;\n"})}),"\n",(0,s.jsx)(n.h4,{id:"rustcfgoptions",children:"RustCfgOptions"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"export type RustCfgOptions = Map<string, string[]>;\n"})}),"\n",(0,s.jsx)(n.h4,{id:"rustrawdependencies",children:"RustRawDependencies"}),"\n",(0,s.jsx)(n.p,{children:"The RustRawDependencies is a mapping between\npackage id and the package's raw dependencies info."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"export type RustRawDependencies = Map<string, RustRawDependency[]>;\n"})}),"\n",(0,s.jsx)(n.h4,{id:"rustdependencies",children:"RustDependencies"}),"\n",(0,s.jsx)(n.p,{children:"The RustDependencies is a mapping between\npackage id and the package's dependencies info."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"export type RustDependencies = Map<string, RustDependency[]>;\n"})})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8379:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>o});var s=t(2515);const r={},a=s.createContext(r);function i(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);